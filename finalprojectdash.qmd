---
title: "EDLD 652 Final Project"
author: James Phillips & Ramtin Ranjpour
output-file: index.html
format:
  dashboard:
    theme: spacelab
execute:
  freeze: false
---

```{r}
#| label: load-packages
#| include: false

library(httr2) # For creating and submitting HTTP requests.
library(jsonlite) # For bidirectional mapping between JSON data and R data.
library(tidyverse) # For dplyr, purrr, tidyr, readr, and lubridate.
library(scales) # For aesthetic changes and methods for automatically determining breaks and labels for axes and legends.
library(knitr) # For report generation.
library(DT) # For the table.
library(htmltools) # For table interactivity.

```

```{r}
#| label: get-parse-code
#| include: false

# DO NOT MODIFY WITHOUT CHECKING WITH JPL PARAMETERS.

sentry_get <- function(query = list()) {
  req <- request("https://ssd-api.jpl.nasa.gov/sentry.api") |> 
    req_url_query(!!!query) |> 
    req_user_agent("R (httr2); Sentry API client") |> 
    req_timeout(30)
  
  resp <- req |> req_perform()
  
  # Per JPL, throws an informative error on non-200.
  resp |> resp_check_status()
  
  txt <- resp |> resp_body_string()
  payload <- fromJSON(txt, simplifyVector = FALSE)
  
  # Handle API-level errors.
  if (!is.null(payload$error)) {
    stop(sprintf("Sentry API error: %s", payload$error), call. = FALSE)
  }
  
  # Version check recommended by JPL.
  ver <- payload$signature$version
  ver <- if (is.null(ver)) NA_character_ else as.character(ver)[1]
  
  if (!is.na(ver) && ver != "2.0") {
    warning(springt(
      "Sentry API signature version is %s (docs show 2.0). Format may differ.",
      ver
    ))
  }
  
  payload
}
```

```{r}
#| label: data-table-load
#| include: false

repair_fields <- function(fields, n_cols) {
  if (is.null(fields) || length(fields) != n_cols) {
    fields <- paste0("col_", seq_len(n_cols))
  } else {
    fields <- as.character(fields)
    bad <- is.na(fields) | trimws(fields) == ""
    fields[bad] <- paste0("col_", which(bad))
  }
  
  make.unique(fields)
}

as_sentry_table <- function(payload) {
  if (is.null(payload$data)) {
    stop("Payload has no $data element.")
  }
  
  dat <- payload$data
  
  if (is.list(dat) && length(dat) > 0 && is.list(dat[[1]])) {
    if (!is.null(names(dat[[1]])) && any(nzchar(names(dat[[1]])))) {
      out <- bind_rows(dat)
      return(as_tibble(out, .name_repair = "unique"))
    }
    
    if (!is.null(payload$fields)) {
      n_cols <- length(payload$fields)
      fields <- repair_fields(payload$fields, n_cols)
      
      rows <- map(dat, ~{
        x <- unlist(.x, use.names = FALSE)
        length(x) <- n_cols
        x
      })
      
      df <- as.data.frame(do.call(rbind, rows), stringsAsFactors = FALSE)
      names(df) <- fields
      return(as_tibble(df, .name_repair = "unique"))
    }
  }
  
  if (is.data.frame(dat)) {
    return(as_tibble(dat, .name_repair = "unique"))
  }
  
  out <- as_tibble(dat, .name_repair = "unique")
  return(out)
}

asteroid_summary <- sentry_get()
asteroid_table <- as_sentry_table(asteroid_summary)

asteroid_table_typed <- asteroid_table |> 
  mutate(
    ps_cum = parse_double(ps_cum),
    ps_max = parse_double(ps_max),
    ip = parse_double(ip),
    h = parse_double(h),
    ts_max = parse_double(ts_max),
    v_inf = parse_double(v_inf),
    diameter = parse_double(diameter),
    last_obs_jd = parse_double(last_obs_jd),
    n_imp = as.integer(n_imp),
    last_obs = as.Date(last_obs)
  ) |> 
  mutate(designation = des)

asteroid_table_typed$last_obs_jd <- NULL
asteroid_table_typed$id <- NULL
asteroid_table_typed$h <- NULL
asteroid_table_typed$des <- NULL

reorder <- c(
  "fullname", "last_obs", "diameter", "ip", "n_imp", "v_inf", "range", "ps_cum", "ps_max", "ts_max"
)

asteroid_table_typed <- asteroid_table_typed |> 
  select(any_of(reorder), everything())

# Use `asteroid_table_typed` dataframe for all visualizations. Modify as needed, but do NOT use `asteroid_table` or `asteroid_summary`.
```

```{r}
#| label: sentry-summary-s
#| include: false

s_payload <- sentry_get(list())

sentry_summary_tbl <- bind_rows(s_payload$data) |> 
  as_tibble(.name_repair = "unique") |> 
  mutate(across(everything(), ~na_if(as.character(.x), "")))

objects_after_2126_tbl <- sentry_summary_tbl |> 
  mutate(
    end_year = suppressWarnings(as.integer(str_extract(range, "(?<=-)\\d{4}$")))
  ) |> 
  filter(!is.na(end_year), end_year > 2126) |> 
  arrange(end_year, fullname) |> 
  select(fullname, range)
```

# Potential Impacts Timeline

::: sidebar
## About This Graph

This graph shows a timeline of possible asteroid impacts based on current data from NASA's "[Sentry: Earth Impact Monitoring](https://cneos.jpl.nasa.gov/sentry/)" system.

Each bubble represents a 10-year time window, beginning with the current decade (2020-2029). Bubble sizes increase based on overall number of possible asteroids with impact risks in those timeframes. Bubble sizes are not proportional.

**A note**: No data is provided after the year 2126 as Sentry only provides tracking information for objects with possible impacts in a 100-year window. Anomalies that do appear are excluded from this visualization but remain in the original dataset potentially as the result of prominent media presence, as is the case with the asteroid 101955 Bennu. The objects are as follows:

```{r}
#| label: after-2126-table
#| echo: false
#| results: asis

if (nrow(objects_after_2126_tbl) == 0) {
  cat("<div style='font-size:0.9em;opacity:0.8;'>None.</div>")
} else {
  knitr::kable(
    objects_after_2126_tbl,
    format = "html",
    col.names = c("Object", "Impact range"),
    escape = TRUE
  )
}
```

`r nrow(objects_after_2126_tbl)`

## Data Recency

```{r, echo=FALSE, results='asis'}
render_utc <- format(Sys.time(), tz = "UTC", "%Y-%m-%dT%H:%M:%SZ")

cat(paste0(
  "<span id='last-updated' data-utc='", render_utc, "'></span><br>",
  "<span id='next-refresh'></span>"
))
```

```{=html}
<script>
  (function () {
    // Read the UTC timestamp embedded by R
    const el = document.getElementById('last-updated');
    if (!el) return;
    
    const utc = el.getAttribute('data-utc');
    const last = new Date(utc);
    
    // Compute next refresh (daily at 14:00 UTC)
    const nextUtc = new Date();
    nextUtc.setUTCHours(14, 0, 0, 0);
    if (new Date() >= nextUtc) {
      nextUtc.setUTCDate(nextUtc.getUTCDate() + 1);
    }
    
    // Format in the viewer's local timezone
    const fmt = new Intl.DateTimeFormat(undefined, {
    dateStyle: 'long',
    timeStyle: 'short'
    });
    
    el.textContent = "This data was last updated on " + fmt.format(last) + ".";
    document.getElementById('next-refresh').textContent = 
      "Next scheduled refresh: " + fmt.format(nextUtc) + ".";
  })();
</script>
```

:::

```{r}
#| label: impacts-timeline-bubble-plot
#| warning: false

bin_width <- 10

impacts_parsed <- asteroid_table_typed |> 
  mutate(
    range = str_trim(range),
    range_ok = str_detect(range, "^\\d{4}\\s*-\\s*\\d{4}$")
  ) |> 
  filter(range_ok) |> 
  separate(
    range,
    into = c("start_year", "end_year"),
    sep = "\\s*-\\s*",
    convert = TRUE,
    remove = FALSE
  ) |> 
  filter(!is.na(start_year), !is.na(end_year), end_year >= start_year)

bin_start <- floor(min(impacts_parsed$start_year) / bin_width) * bin_width
bin_end <- ceiling(max(impacts_parsed$end_year) / bin_width) * bin_width
  
impacts_timeline <- tibble(
  bin_lo = seq(bin_start, bin_end - bin_width, by = bin_width),
  bin_hi = bin_lo + bin_width - 1
) |> 
  rowwise() |> 
  mutate(
    n_objects = sum(impacts_parsed$start_year <= bin_hi & impacts_parsed$end_year >= bin_lo),
    bin_mid = (bin_lo + bin_hi) / 2,
    bin_label = paste0(bin_lo, "-", bin_hi)
  ) |> 
  ungroup() |> 
  filter(n_objects > 0) |> 
  arrange(bin_mid) |> 
  mutate(
    y = 0,
    side = if_else(row_number() %% 2 == 0, "below", "above"),
    y_label = if_else(side == "above", 0.40, -0.40),
    y_line_end = if_else(side == "above", 0.32, -0.32),
    label = paste0(bin_label, "\n(n = ", n_objects, ")")
  )

xmin <- min(impacts_timeline$bin_lo)
xmax <- max(impacts_timeline$bin_hi)

ggplot(impacts_timeline, aes(x = bin_mid, y = y)) +
  geom_segment(
    aes(x = xmin, xend = xmax, y = 0, yend = 0),
    inherit.aes = FALSE,
    linewidth = 1.1,
    arrow = arrow(length = unit(0.22, "cm"), type = "closed")
  ) +
  geom_segment(
    aes(xend = bin_mid, yend = y_line_end),
    linewidth = 0.35, alpha = 0.35
  ) +
  geom_point(
    aes(size = n_objects),
    shape = 21,
    fill = "#56B4E9",
    color = "#56B4E9",
    alpha = 0.65
  ) +
  geom_text(
    aes(y = y_label, label = label),
    size = 2.5,
    lineheight = 0.95,
    angle = 45,
    hjust = 0.5,
    vjust = 0.5) +
  scale_x_continuous(
    name = NULL,
    breaks = NULL,
    labels = NULL,
    expand = expansion(mult = c(0.05, 0.10))
  ) +
  scale_y_continuous(
    name = NULL,
    breaks = NULL
  ) +
  scale_size(range = c(4, 20), guide = "none") +
  coord_cartesian(clip = "off") +
  theme_void(base_size = 14) +
  theme(
    plot.margin = margin(25, 25, 25, 25))
```

# Sentry Object Table

## Click an object name to view details

::: {.columns}
::: {.column width="60%"}

```{r}
#| label: sentry-object-table
#| echo: false

obj_tbl <- asteroid_table_typed |> 
  transmute(
    designation,
    fullname,
    range,
    n_imp,
    ip,
    v_inf,
    diameter,
    ps_cum,
    ps_max,
    ts_max,
    last_obs
  )

datatable(
  obj_tbl,
  rownames = FALSE,
  selection = "single",
  options = list(
    pagelength = 15,
    autoWidth = TRUE,
    scrollX = TRUE,
    columnDefs = list(list(targets = 0, visible = FALSE))
  ),
  callback = DT::JS("
    // When row is clicked, fetch details via the Sentry API and render to the panel.
    table.on('click.dt', 'tr', function() {
      var row = table.row(this);
      if (!row || !row.data()) return;
      
      var data = row.data();
      var des = data[0]; // hidden 'designation'
      
      var panel = document.getElementById('sentry-details');
      panel.innerHTML = '<div style=\"opacity:.8;\">Loading details for <b>' + des + '</b>...</div>';
      
      var url = 'https://ssd-api.jpl.nasa.gov/sentry.api?des=' + encodeURIComponent(des);
      
      fetch(url)
        .then(r => r.json())
        .then(payload => {
          if (payload.error) {
            panel.innerHTML = '<div style=\"color:#b00020;\">API error: ' + payload.error + '</div>';
            return;
          }
          
          // payload.summary is a list; payload.data is the impact table
          var s = (payload.summary && payload.summary.length) ? payload.summary[0] : null;
          if (!s) {
            panel.innerHTML = '<div>No summary available for ' + des + '.</div>';
            return;
          }
          
          // Build a compact summary
          var html = '';
          html += '<h3 style=\"margin-top:0;\">' + (s.fullname || des) + '</h3>';
          html += '<div style=\"display:grid;grid-template-columns:1fr 1fr;gap:8px;\">';
          html += '<div><b>Year range:</b> ' + (s.range ?? '') + '</div>';
          html += '<div><b>Potential impacts:</b> ' + (s.n_imp ?? '') + '</div>';
          html += '<div><b>Cumulative IP:</b> ' + (s.ip ?? '') + '</div>';
          html += '<div><b>Vâˆž (km/s):</b> ' + (s.v_inf ?? '') + '</div>';
          html += '<div><b>Diameter (km):</b> ' + (s.diameter ?? '') + '</div>';
          html += '<div><b>Torino max:</b> ' + (s.ts_max ?? '') + '</div>';
          html += '<div><b>Palermo cum:</b> ' + (s.ps_cum ?? '') + '</div>';
          html += '<div><b>Palermo max:</b> ' + (s.ps_max ?? '') + '</div>';
          html += '</div>';
          
          // Build a small impacts table (first ~10 rows for readability)
          var impacts = payload.data || [];
          html += '<h4 style=\"margin-top:14px;\">Impact events (sample)</h4>';
          
          if (!impacts.length) {
            html += '<div style=\"opacity:.8;\">No impact-event rows returned.</div>';
          } else {
            var head = Object.keys(impacts[0]);
            var showCols = ['date', 'ip', 'ps', 'ts', 'sigma', 'energy']; // best-effort
            var cols = head.filter(h => showCols.includes(h)).slice(0, 6);
            if (!cols.length) cols = head.slice(0, 6);

            html += '<table style=\"width:100%;border-collapse:collapse;\">';
            html += '<thead><tr>' + cols.map(c => '<th style=\"text-align:left;border-bottom:1px solid #ddd;padding:4px;\">' + c + '</th>').join('') + '</tr></thead>';
            html += '<tbody>';

            impacts.slice(0, 10).forEach(row => {
              html += '<tr>' + cols.map(c => '<td style=\"border-bottom:1px solid #f0f0f0;padding:4px;\">' + (row[c] ?? '') + '</td>').join('') + '</tr>';
            });

            html += '</tbody></table>';
            html += '<div style=\"margin-top:6px;opacity:.75;font-size:.9em;\">Showing 10 rows; API returned ' + impacts.length + '.</div>';
          }
          
          panel.innerHTML = html;
        })
        .catch(err => {
        panel.innerHTML = '<div style=\"color:#b00020;\">Fetch failed: ' + err + '</div>';
      });
    })
    })
  ")
)
```

