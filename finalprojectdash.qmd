---
title: "EDLD 652 Final Project"
author: James Phillips & Ramtin Ranjpour
output-file: index.html
format:
  dashboard:
    theme: spacelab
execute:
  freeze: false
---

```{r}
#| label: load-packages
#| include: false

library(httr2) # For creating and submitting HTTP requests.
library(jsonlite) # For bidirectional mapping between JSON data and R data.
library(tidyverse) # For dplyr, purrr, tidyr, readr, and lubridate.
library(scales) # For aesthetic changes and methods for automatically determining breaks and labels for axes and legends.

```

```{r}
#| label: get-parse-code
#| include: false

# DO NOT MODIFY WITHOUT CHECKING WITH JPL PARAMETERS.

sentry_get <- function(query = list()) {
  req <- request("https://ssd-api.jpl.nasa.gov/sentry.api") |> 
    req_url_query(!!!query) |> 
    req_user_agent("R (httr2); Sentry API client") |> 
    req_timeout(30)
  
  resp <- req |> req_perform()
  
  # Per JPL, throws an informative error on non-200.
  resp |> resp_check_status()
  
  txt <- resp |> resp_body_string()
  payload <- fromJSON(txt, simplifyVector = FALSE)
  
  # Handle API-level errors.
  if (!is.null(payload$error)) {
    stop(sprintf("Sentry API error: %s", payload$error), call. = FALSE)
  }
  
  # Version check recommended by JPL.
  ver <- payload$signature$version
  ver <- if (is.null(ver)) NA_character_ else as.character(ver)[1]
  
  if (!is.na(ver) && ver != "2.0") {
    warning(springf(
      "Sentry API signature version is %s (docs show 2.0). Format may differ.",
      ver
    ))
  }
  
  payload
}
```

```{r}
#| label: data-table-load
#| include: false

repair_fields <- function(fields, n_cols) {
  if (is.null(fields) || length(fields) != n_cols) {
    fields <- paste0("col_", seq_len(n_cols))
  } else {
    fields <- as.character(fields)
    bad <- is.na(fields) | trimws(fields) == ""
    fields[bad] <- paste0("col_", which(bad))
  }
  
  make.unique(fields)
}

as_sentry_table <- function(payload) {
  if (is.null(payload$data)) {
    stop("Payload has no $data element.")
  }
  
  dat <- payload$data
  
  if (is.list(dat) && length(dat) > 0 && is.list(dat[[1]])) {
    if (!is.null(names(dat[[1]])) && any(nzchar(names(dat[[1]])))) {
      out <- bind_rows(dat)
      return(as_tibble(out, .name_repair = "unique"))
    }
    
    if (!is.null(payload$fields)) {
      n_cols <- length(payload$fields)
      fields <- repair_fields(payload$fields, n_cols)
      
      rows <- map(dat, ~{
        x <- unlist(.x, use.names = FALSE)
        length(x) <- n_cols
        x
      })
      
      df <- as.data.frame(do.call(rbind, rows), stringsAsFactors = FALSE)
      names(df) <- fields
      return(as_tibble(df, .name_repair = "unique"))
    }
  }
  
  if (is.data.frame(dat)) {
    return(as_tibble(dat, .name_repair = "unique"))
  }
  
  out <- as_tibble(dat, .name_repair = "unique")
  return(out)
}

asteroid_summary <- sentry_get()
asteroid_table <- as_sentry_table(asteroid_summary)

asteroid_table_typed <- asteroid_table |> 
  mutate(
    ps_cum = parse_double(ps_cum),
    ps_max = parse_double(ps_max),
    ip = parse_double(ip),
    h = parse_double(h),
    ts_max = parse_double(ts_max),
    v_inf = parse_double(v_inf),
    diameter = parse_double(diameter),
    last_obs_jd = parse_double(last_obs_jd),
    n_imp = as.integer(n_imp),
    last_obs = as.Date(last_obs)
  )

asteroid_table_typed$last_obs_jd <- NULL
asteroid_table_typed$id <- NULL
asteroid_table_typed$h <- NULL
asteroid_table_typed$des <- NULL

reorder <- c(
  "fullname", "last_obs", "diameter", "ip", "n_imp", "v_inf", "range", "ps_cum", "ps_max", "ts_max"
)

asteroid_table_typed <- asteroid_table_typed |> 
  select(any_of(reorder), everything())

# Use `asteroid_table_typed` dataframe for all visualizations. Modify as needed, but do NOT use `asteroid_table` or `asteroid_summary`.
```

```{r}
#| label: virtual-impactors
#| include: false

# This is a possible limiting of the dataset for visualization purposes.

v_payload <- sentry_get(list(all = "1", `ip-min` = "1e-6"))

vi_tbl <- bind_rows(v_payload$data) |> 
  as_tibble(.name_repair = "unique") |> 
  mutate(across(everything(), ~na_if(as.character(.x), "")))

num_cols <- c(
  "ip", "ps", "ts", "h", "diameter", "v_inf", "last_obs_jd", "sigma", "width", "stretch", "energy", "t_sigma"
)
date_cols <- c("last_obs")

present_num_cols <- intersect(names(vi_tbl), num_cols)
present_date_cols <- intersect(names(vi_tbl), date_cols)

vi_tbl_typed <- vi_tbl |> 
  mutate(
    across(all_of(present_num_cols), readr::parse_double),
    across(all_of(present_date_cols), as.Date)
)
```

```{r}
#| label: obj-details
#| include: false

# This allows for accessing specific objects based on their designation. At current, "101955" is Bennu.

o_payload <- sentry_get(list(des = "101955"))

obj_summary_tbl <- bind_rows(o_payload$summary) |> 
  as_tibble(.name_repair = "unique") |> 
  mutate(across(everything(), ~na_if(as.character(.x), "")))

obj_impacts_tbl <- bind_rows(o_payload$data) |> 
  as_tibble(.name_repair = "unique") |> 
  mutate(across(everything(), ~na_if(as.character(.x), "")))
```

# Potential Impacts Timeline

::: sidebar
## About This Graph

This graph shows a timeline of possible asteroid impacts based on current data from NASA's "[Sentry: Earth Impact Monitoring](https://cneos.jpl.nasa.gov/sentry/)" system. Each bubble represents a 10-year time window, beginning with the current decade (2020-2029). Bubble sizes increase based on overall number of possible asteroids with impact risks in those timeframes. Bubble sizes are not proportional.

## Data Recency

This data was last updated on <insert refresh date and time here>.
:::

```{r}
#| label: impacts-timeline-bubble-plot

bin_width <- 10

impacts_parsed <- asteroid_table_typed |> 
  mutate(
    range = str_trim(range),
    range_ok = str_detect(range, "^\\d{4}\\s*-\\s*\\d{4}$")
  ) |> 
  filter(range_ok) |> 
  separate(
    range,
    into = c("start_year", "end_year"),
    sep = "\\s*-\\s*",
    convert = TRUE,
    remove = FALSE
  ) |> 
  filter(!is.na(start_year), !is.na(end_year), end_year >= start_year)

bin_start <- floor(min(impacts_parsed$start_year) / bin_width) * bin_width
bin_end <- ceiling(max(impacts_parsed$end_year) / bin_width) * bin_width
  
impacts_timeline <- tibble(
  bin_lo = seq(bin_start, bin_end - bin_width, by = bin_width),
  bin_hi = bin_lo + bin_width - 1
) |> 
  rowwise() |> 
  mutate(
    n_objects = sum(impacts_parsed$start_year <= bin_hi & impacts_parsed$end_year >= bin_lo),
    bin_mid = (bin_lo + bin_hi) / 2,
    bin_label = paste0(bin_lo, "-", bin_hi)
  ) |> 
  ungroup() |> 
  filter(n_objects > 0) |> 
  arrange(bin_mid) |> 
  mutate(
    y = 0,
    side = if_else(row_number() %% 2 == 0, "below", "above"),
    y_label = if_else(side == "above", 0.40, -0.40),
    y_line_end = if_else(side == "above", 0.24, -0.24),
    label = paste0(bin_label, "\n(n = ", n_objects, ")")
  )

xmin <- min(impacts_timeline$bin_lo)
xmax <- max(impacts_timeline$bin_hi)

ggplot(impacts_timeline, aes(x = bin_mid, y = y)) +
  geom_segment(
    aes(x = xmin, xend = xmax, y = 0, yend = 0),
    inherit.aes = FALSE,
    linewidth = 1.1,
    arrow = arrow(length = unit(0.22, "cm"), type = "closed")
  ) +
  geom_segment(
    aes(xend = bin_mid, yend = y_line_end),
    linewidth = 0.35, alpha = 0.35
  ) +
  geom_point(
    aes(size = n_objects),
    shape = 21,
    fill = "#56B4E9",
    color = "#56B4E9",
    alpha = 0.65
  ) +
  geom_text(
    aes(y = y_label, label = label),
    fontface = "bold", size = 4, lineheight = 0.95) +
  scale_x_continuous(
    name = NULL,
    breaks = NULL,
    labels = NULL
  ) +
  scale_y_continuous(
    name = NULL,
    breaks = NULL
  ) +
  scale_size(range = c(6, 30), guide = "none") +
  coord_cartesian(clip = "off") +
  theme_void(base_size = 14) +
  theme(
    plot.margin = margin(25, 25, 25, 25))
```

